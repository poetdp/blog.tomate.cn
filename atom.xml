<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>番茄 Boy</title>
  
  <subtitle>Rocj&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.tomate.cn/"/>
  <updated>2018-03-17T05:38:43.952Z</updated>
  <id>http://blog.tomate.cn/</id>
  
  <author>
    <name>rocj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 Ubuntu 搭建 Seafile 个人网盘</title>
    <link href="http://blog.tomate.cn/2017/07/24/set-up-seafile-network-storage-via-ubuntu/"/>
    <id>http://blog.tomate.cn/2017/07/24/set-up-seafile-network-storage-via-ubuntu/</id>
    <published>2017-07-24T09:04:58.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备域名"><a href="#准备域名" class="headerlink" title="准备域名"></a>准备域名</h2><ul><li>域名注册</li><li>域名解析</li></ul><p>域名购买完成后, 需要将域名解析到云主机上，通 <code>ping</code> 命令检查域名是否生效，如：</p><pre><code>ping www.yourdomain.com</code></pre><p>如果 <code>ping</code> 命令返回的信息中含有你设置的解析的 IP 地址，说明解析成功。</p><blockquote><p>注意替换下面命令中的 <a href="http://www.yourdomain.com" target="_blank" rel="noopener">www.yourdomain.com</a> 为您自己的注册的域名</p></blockquote><h2 id="安装-Seafile-服务器"><a href="#安装-Seafile-服务器" class="headerlink" title="安装 Seafile 服务器"></a>安装 Seafile 服务器</h2><p><strong>安装依赖环境</strong></p><p>在 Debian/Ubuntu 系统下，可以使用以下命令安装 MySQL：</p><pre><code>sudo apt-get updatesudo apt-get install mysql-server</code></pre><p>使用以下命令安装 Python 相关依赖：</p><pre><code>sudo apt-get install python2.7 python-setuptools python-imaging python-ldap python-mysqldb python-memcache python-urllib3</code></pre><p>安装 MySQL 过程需要为 MySQL 的 root 用户设置新密码，请记住该 [密码] 以供后面步骤使用。</p><p><strong>为 Seafile 创建一个用户</strong></p><p>创建 Seafile 用户，使用它运行 Seafile 服务：</p><pre><code>sudo useradd -m -s /bin/bash seafile</code></pre><p>为该用户设置密码：</p><pre><code>sudo passwd seafile</code></pre><p><strong>下载Seafile</strong></p><p>切换到新用户，需要输入你刚才为seafile用户设置的密码：</p><pre><code>su - seafile</code></pre><p>切换目录：</p><pre><code>cd ~</code></pre><p>这里可以查看获取最新 Seafile 下载链接，参考以下命令进行下载。</p><pre><code>wget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.1.1_i386.tar.gz</code></pre><p>解压:</p><pre><code>tar -xzf seafile-server_*mv seafile-server-*/ seafile-server/</code></pre><p><strong>配置 Seafile</strong></p><p>运行Seafile设置脚本，并回答预设问题：</p><pre><code>cd seafile-server*./setup-seafile-mysql.sh</code></pre><p>执行过程输入参数如下图：</p><p>其中：</p><p>[ This server’s ip or domain ] 字段输入教程第一步申请的域名或者IP地址（&lt;您的 CVM IP 地址&gt;）。<br>mysql 的 [ root password ] 字段输入数据库密码。<br>其他字段一路回车使用默认值。</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-f9c351cd604618ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>启动 Seafile</strong></p><pre><code>./seafile.sh start./seahub.sh start</code></pre><p>执行过程输入参数如截图所示，其中 [ admin email ] 设置为您登录网盘的帐号，如 <a href="mailto:`admin@qcloudlab.wang" target="_blank" rel="noopener">`admin@qcloudlab.wang</a>`。</p><p>[ admin password ] 和 [ admin password again ] 设置为登录网盘的密码，如  <code>admin_Password</code> ：</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-a53a5ff6fc6678e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>大功告成！恭喜，您的 Seafile 已经部署完成，您现在拥有专属的网盘了，登录的帐号密码为您启动 Seafile 步骤中设置的邮箱和密码。</p><ul><li>可以通过 IP 访问网盘：http://&lt;您的域名&gt;:8000</li><li>可以通过域名访问网盘：如 <a href="http://www.yourdomain.com:8000" target="_blank" rel="noopener">http://www.yourdomain.com:8000</a> ，其中 <a href="http://www.yourdomain.com" target="_blank" rel="noopener">www.yourdomain.com</a> 替换为您注册的域名</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备域名&quot;&gt;&lt;a href=&quot;#准备域名&quot; class=&quot;headerlink&quot; title=&quot;准备域名&quot;&gt;&lt;/a&gt;准备域名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;域名注册&lt;/li&gt;
&lt;li&gt;域名解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;域名购买完成后, 需要将域名解析到云主机上，通
      
    
    </summary>
    
      <category term="折腾" scheme="http://blog.tomate.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Seafile" scheme="http://blog.tomate.cn/tags/Seafile/"/>
    
      <category term="网盘" scheme="http://blog.tomate.cn/tags/%E7%BD%91%E7%9B%98/"/>
    
      <category term="Ubuntu" scheme="http://blog.tomate.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>基于 CentOS 搭建 Seafile 个人网盘</title>
    <link href="http://blog.tomate.cn/2017/07/24/set-up-seafile-network-storage-via-centos/"/>
    <id>http://blog.tomate.cn/2017/07/24/set-up-seafile-network-storage-via-centos/</id>
    <published>2017-07-24T08:04:58.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备域名"><a href="#准备域名" class="headerlink" title="准备域名"></a>准备域名</h2><ul><li>域名注册</li><li>域名解析</li></ul><p>域名购买完成后, 需要将域名解析到云主机上，通 <code>ping</code> 命令检查域名是否生效，如：</p><pre><code>ping www.yourdomain.com</code></pre><p>如果 <code>ping</code> 命令返回的信息中含有你设置的解析的 IP 地址，说明解析成功。</p><blockquote><p>注意替换下面命令中的 <a href="http://www.yourdomain.com" target="_blank" rel="noopener">www.yourdomain.com</a> 为您自己的注册的域名</p></blockquote><h2 id="安装-Seafile"><a href="#安装-Seafile" class="headerlink" title="安装 Seafile"></a>安装 Seafile</h2><p><strong>安装依赖环境</strong></p><p>使用 yum 安装 Python 及 MySQL：</p><pre><code>yum install python python-setuptools python-imaging python-ldap python-memcached MySQL-python mariadb mariadb-server</code></pre><p>启动 MariaDB 服务：</p><pre><code>sudo systemctl start mariadb.servicesudo systemctl enable mariadb.service</code></pre><p>配置 MySQL：</p><pre><code>/usr/bin/mysql_secure_installation</code></pre><p>配置过程输入参数如截图所示，其中 <code>New password</code> 和 <code>Re-enter new password</code> 字段都为你自己设置的密码 <code>yourmysqlpassword</code>，其他字段一路回车使用默认值：</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-3ad5bb73b5da05f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>安装 Seafile</strong></p><p>下载 Seafile 安装包：</p><pre><code>wget http://seafile-downloads.oss-cn-shanghai.aliyuncs.com/seafile-server_6.1.1_x86-64.tar.gz</code></pre><p>解压 Seafile 安装包：</p><pre><code>tar -zxvf seafile-server_6.1.1_x86-64.tar.gz</code></pre><p>安装 Seafile 安装包：</p><pre><code>sudo mkdir -p /opt/seafile/installedsudo mv seafile-server_6.1.1_x86-64.tar.gz /opt/seafile/installedsudo mv seafile-server-6.1.1/ /opt/seafilecd /opt/seafile/seafile-server-6.1.1sudo ./setup-seafile-mysql.sh</code></pre><p>执行过程输入参数如截图所示，[server name] 字段输入 <code>Seafile</code>，[ This server’s ip or domain ] 字段输入教程第一步申请的域名，[ 1 or 2 ] 字段选择 1，mysql 的 [ root password ] 字段输入你自己设置的密码 <code>yourmysqlpassword</code>，其他字段一路回车使用默认值：</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-bafb4a1b2054c922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>启动 Seafile 及修改防火墙规则</strong></p><p>启动 Seafile</p><pre><code>sudo ./seafile.sh startsudo ./seahub.sh start</code></pre><p>执行过程输入参数如截图所示，其中 [ admin email ] 设置为您登录网盘的 <code>邮箱帐号</code>，[ admin password ] 和 [ admin password again ] 设置为登录网盘的 <code>密码</code> ：</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-e04142f8a9cfb762.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>修改防火墙规则（可选）</p><pre><code>sudo firewall-cmd --zone=public --permanent --add-port=8082/tcpsudo firewall-cmd --zone=public --permanent --add-port=8000/tcpsudo firewall-cmd --reload</code></pre><p>大功告成！你的 Seafile 已经部署完成，登录的帐号密码为您启动 Seafile 步骤中设置的邮箱和密码。</p><ul><li>可以通过 Ip 访问网盘：http://&lt;你的ip&gt;:8000</li><li>也可以通过域名访问网盘：如 <a href="http://www.yourdomain.com:8000" target="_blank" rel="noopener">http://www.yourdomain.com:8000</a> ，其中 <a href="http://www.yourdomain.com" target="_blank" rel="noopener">www.yourdomain.com</a> 替换为您注册的域名</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备域名&quot;&gt;&lt;a href=&quot;#准备域名&quot; class=&quot;headerlink&quot; title=&quot;准备域名&quot;&gt;&lt;/a&gt;准备域名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;域名注册&lt;/li&gt;
&lt;li&gt;域名解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;域名购买完成后, 需要将域名解析到云主机上，通
      
    
    </summary>
    
      <category term="折腾" scheme="http://blog.tomate.cn/categories/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="CentOS" scheme="http://blog.tomate.cn/tags/CentOS/"/>
    
      <category term="Seafile" scheme="http://blog.tomate.cn/tags/Seafile/"/>
    
      <category term="网盘" scheme="http://blog.tomate.cn/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Win10+Linux 双系统方案中的 ‘坑’</title>
    <link href="http://blog.tomate.cn/2017/07/09/the-hole-in-pc-with-win10-and-linux/"/>
    <id>http://blog.tomate.cn/2017/07/09/the-hole-in-pc-with-win10-and-linux/</id>
    <published>2017-07-09T05:08:00.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一坑：双系统时间不一致"><a href="#第一坑：双系统时间不一致" class="headerlink" title="第一坑：双系统时间不一致"></a>第一坑：双系统时间不一致</h2><p>首先科普一下 <a href="http://www.cnblogs.com/tosee/p/5538007.html" target="_blank" rel="noopener">GMT 和 UTC</a></p><p>Windows 和 Linux 计算系统时间的默认方法是不同的：</p><ul><li>Windows 把 <code>BIOS 时间</code> 当做 <code>系统时间</code>;</li><li>Linux 把 <code>BIOS 时间</code> 当做 <code>UTC 时间</code>，而北京是东八时区，所以系统显示的时间是 UTC+8，比正常时间快了 8 小时</li></ul><p>解决方法有下面两种：</p><ul><li>让 Linux 把 BIOS 时间 当做正常时间</li></ul><pre><code class="shell">sudo gedit /etc/default/rcS# 把 UTC=yes 改为 no</code></pre><ul><li>让 Windows 把 BIOS 时间 当做 UTC 时间</li></ul><pre><code>// 在 cmd 中输入：Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</code></pre><p><a href="http://blog.csdn.net/misiter/article/details/7767146" target="_blank" rel="noopener">其他方法</a></p><h2 id="第二坑：Win-10-关机后-Linux-对磁盘不可写"><a href="#第二坑：Win-10-关机后-Linux-对磁盘不可写" class="headerlink" title="第二坑：Win 10 关机后 Linux 对磁盘不可写"></a>第二坑：Win 10 关机后 Linux 对磁盘不可写</h2><p>从 win 8 开始，windows 的开机速度变得飞快，其原理就是 <code>关机 类似于 休眠</code>，关机前关掉所有程序，将下次开机时需要的数据存到硬盘上，开机时只需将硬盘中的数据读取到内存中。</p><p>这样做就有一个坑，Windows 关机后再进入 Linux 系统后，硬盘的 <code>非 Linux 所在分区</code> 表现为 <code>只读状态</code>，无法写入、删除数据。</p><p>在百度上也没找到这个问题，个人认为是 Windows 的 <code>关机即休眠</code> 原理造成的，于是我做了一个测试：</p><blockquote><p>在 Windows 重启到 BIOS 界面时立即进入 Linux 系统，这时发现 Linux 对所有磁盘的读写已经正常了</p></blockquote><p>所以这个问题可以这样解决：</p><ul><li>在 Windows 完全关机的状态下再进入 Linux，这种方法每次进 Linux 系统都比较麻烦</li><li>在 Windows 电源选项中关掉 <code>快速启动</code>，这种方法会使得 Windows 开机变慢</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一坑：双系统时间不一致&quot;&gt;&lt;a href=&quot;#第一坑：双系统时间不一致&quot; class=&quot;headerlink&quot; title=&quot;第一坑：双系统时间不一致&quot;&gt;&lt;/a&gt;第一坑：双系统时间不一致&lt;/h2&gt;&lt;p&gt;首先科普一下 &lt;a href=&quot;http://www.cnb
      
    
    </summary>
    
      <category term="Default" scheme="http://blog.tomate.cn/categories/Default/"/>
    
    
      <category term="win10" scheme="http://blog.tomate.cn/tags/win10/"/>
    
      <category term="linux" scheme="http://blog.tomate.cn/tags/linux/"/>
    
      <category term="双系统" scheme="http://blog.tomate.cn/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>git 使用 http(s) 协议时该如何保存用户名和密码</title>
    <link href="http://blog.tomate.cn/2017/05/30/git-https-save-username-and-password/"/>
    <id>http://blog.tomate.cn/2017/05/30/git-https-save-username-and-password/</id>
    <published>2017-05-30T09:15:25.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>git 使用 http(s) 方式每次都要输入密码，下面有几种方法可以解决输入密码的困扰又能享受https带来的极速</p><ul><li>暂时记住密码（默认15分钟）：</li></ul><pre><code class="bash">git config --global credential.helper cache# 如果想自己设置时间，可以这样做：git config credential.helper &#39;cache --timeout=3600&#39;# 这样就设置一个小时之后失效</code></pre><ul><li>长期存储密码：</li></ul><pre><code class="bash">git config --global credential.helper store</code></pre><ul><li>在远程地址中加上密码（推荐）</li></ul><pre><code class="bash">git remote add origin http://username:password@github.com/username/repo.git</code></pre><p>修改已有仓库的地址可以这样做</p><pre><code class="bash">git remote rm origingit remote add origin http://username:password@github.com/username/repo.git</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git 使用 http(s) 方式每次都要输入密码，下面有几种方法可以解决输入密码的困扰又能享受https带来的极速&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂时记住密码（默认15分钟）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;git config --g
      
    
    </summary>
    
      <category term="Git" scheme="http://blog.tomate.cn/categories/Git/"/>
    
    
      <category term="git" scheme="http://blog.tomate.cn/tags/git/"/>
    
      <category term="https" scheme="http://blog.tomate.cn/tags/https/"/>
    
      <category term="密码" scheme="http://blog.tomate.cn/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>算法练习：数字重组</title>
    <link href="http://blog.tomate.cn/2017/05/30/algorithm-practice-digit-recombination/"/>
    <id>http://blog.tomate.cn/2017/05/30/algorithm-practice-digit-recombination/</id>
    <published>2017-05-30T07:30:41.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>输入一个N位高精度的正整数，去掉其中任意K个数字后剩下的数字按原左右次序组成一个新的正整数。写算法对给定的N和K，寻找一种方案使得剩下的数字组成的新数最小。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>N、K以及一个N位高精度的正整数</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>剩下的数字组成的最小新数</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>20 5<br>89382735464109218767</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>235464109218767</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;char find_min(char *c, int left, int right, int &amp;pmin) {    char min;    min=c[left]; pmin=left; left++;    while(left&lt;=right) {        if(c[left]&lt;min) { min=c[left]; pmin=left;}        left++;    }    return min;}int main() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    char *c = new char [n];    int i, pmin=0, tag=-1;    for(i=0; i&lt;n; i++) {        cin &gt;&gt; c[i];    }    for(i=1; i&lt;=n-k; i++) {        cout &lt;&lt; find_min(c, tag+1, k+i-1, pmin);        tag=pmin;    }    cout &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h5&gt;&lt;p&gt;输入一个N位高精度的正整数，去掉其中任意K个数字后剩下的数字按原左右
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.tomate.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.tomate.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数字" scheme="http://blog.tomate.cn/tags/%E6%95%B0%E5%AD%97/"/>
    
      <category term="重组" scheme="http://blog.tomate.cn/tags/%E9%87%8D%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>js 变量检查（防止sql注入）</title>
    <link href="http://blog.tomate.cn/2017/05/21/js-parameter-check-avoid-sql-inject/"/>
    <id>http://blog.tomate.cn/2017/05/21/js-parameter-check-avoid-sql-inject/</id>
    <published>2017-05-21T06:33:49.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="javascript">/* * @param 可能是对象、数组、字符串 * 检查param中是否含有空白符、引号等，如果有则自动删除这些符号返回一个合法的数据 */function check(param) {    if(typeof param == &quot;object&quot;) {        for(var item in param) {            if(typeof param[item] == &quot;string&quot;)                param[item] = param[item].replace(/\s|&#39;|&quot;|%|\?/g, &quot;&quot;);        }    }    else if(typeof param == &quot;string&quot;) {        param = param.replace(/\s|&#39;|&quot;|%|\?/g, &quot;&quot;);    }    return param;}//test sampleo1 = {a:1, b:&quot;2 3&quot;, c:&quot;&#39;user&#39; or 1=1&quot;};o2 = [&quot;double kill&quot;, &quot;triple    kill&quot;];o3 = &quot;i love    &#39;u&#39;\n&quot;;console.log(o1.a, o1.b, o1.c);o1 = check(o1);console.log(o1.a, o1.b, o1.c);console.log(o2[0], o2[1]);o2 = check(o2);console.log(o2[0], o2[1]);console.log(o3);o3 = check(o3);console.log(o3);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;/*
 * @param 可能是对象、数组、字符串
 * 检查param中是否含有空白符、引号等，如果有则自动删除这些符号返回一个合法的数据
 */
function check(param) {
    if(type
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.tomate.cn/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.tomate.cn/tags/js/"/>
    
      <category term="变量检查" scheme="http://blog.tomate.cn/tags/%E5%8F%98%E9%87%8F%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>OJ1465 子集和数问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1465/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1465/</id>
    <published>2017-05-18T15:47:02.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>子集和数问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:933 Accepted:282</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>已知n个不同正整数wi，0&lt;=i&lt;=n-1，的集合，求该集合的所有满足条件的子集，使得每个子集中的正整数之和等于另一个给定的正整数M。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入n和M的值，第二行输入n个不同的正整数wi（i=0，…，n）。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>如果有答案，则输出所有满足条件的子集（用固定长度n-元组xi表示，xi=0或1，i=0，…，n）。如果没有答案，则输出“no solution!”。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>4 31<br>11 13 24 7</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>1 1 0 1<br>0 0 1 1</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;void SumOfSub(int s, int k, int r, int **x, int m, int *w, int n, int &amp;count) {    x[k][1]=1;    if(s+w[k] == m) {        count++;        int i, j;        for(i=0; i&lt;n; i++) {            for(j=0; j&lt;=k; j++) {                if(x[j][0] == i) {                    cout &lt;&lt; x[j][1] &lt;&lt; &quot; &quot;;                    break;                }            }            if(j &gt; k)                cout &lt;&lt; &quot;0 &quot;;        }        cout &lt;&lt; endl;    }    else if(s+w[k]+w[k+1] &lt;= m)        SumOfSub(s+w[k], k+1, r-w[k], x, m, w, n, count);    if(s+r-w[k]&gt;=m &amp;&amp; s+w[k+1]&lt;=m) {        x[k][1]=0;        SumOfSub(s, k+1, r-w[k], x, m, w, n, count);    }}void SumOfSub(int **x, int n, int m, int *w, int &amp;count) {    int r=0;    for(int i=0; i&lt;n; i++)        r+=w[i];    if(r&gt;=m &amp;&amp; w[0]&lt;=m)        SumOfSub(0, 0, r, x, m, w, n, count);}int main() {    int n, M, count=0;    cin &gt;&gt; n &gt;&gt; M;    int *w = new int [n];    int **x = new int * [n];    for(int i=0; i&lt;n; i++)        x[i] = new int [2];    for(int i=0; i&lt;n; i++) {         cin &gt;&gt; w[i];        x[i][0]=i;    }    int i, j, t;    for(i=0; i&lt;n; i++) {        for(j=i+1; j&lt;n; j++) {            if(w[i] &gt; w[j]) {                t=w[i]; w[i]=w[j]; w[j]=t;                t=x[i][0]; x[i][0]=x[j][0]; x[j][0]=t;            }        }    }    SumOfSub(x, n, M, w, count);    if(count==0)        cout &lt;&lt; &quot;no solution!&quot;;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;子集和数问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:933 Accepted:282&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; cla
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1464 N皇后问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1464/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1464/</id>
    <published>2017-05-18T15:46:56.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>NQeens</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:455 Accepted:288</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>n-皇后问题要求在一个n*n的棋盘上放置n个皇后，使得它们彼此不受“攻击”。观察表明n-皇后问题的解存在垂直对偶性，请修改教材算法NQeens，令x[0]=1，2，……，[n/2]，使得只求其中不对称的那些解。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>n的值。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>不对称的那些解。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>4</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>1 3 0 2</p><h5 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h5><p>4-皇后全部的解为<br>1 3 0 2<br>2 0 3 1</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;bool Place(int k, int i, int *x) {    for(int j=0; j&lt;k; j++) {        if(x[j]==i || abs(x[j]-i)==abs(j-k))            return false;    }    return true;}void NQueens(int k, int n, int *x) {    int i, j;    for(i=0; i&lt;(k==0?n/2:n); i++) {        if(Place(k, i, x)) {            x[k]=i;            if(k == n-1) {                for(j=0; j&lt;n; j++)                    cout &lt;&lt; x[j] &lt;&lt; &#39; &#39;;                cout &lt;&lt; endl;            }            else NQueens(k+1, n, x);        }    }}void NQueens(int n, int *x) {    NQueens(0, n, x);}int main() {    int n;    cin &gt;&gt; n;    int *x = new int [n];    NQueens(n, x);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NQeens&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:455 Accepted:288&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; cla
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1463 最长公共子序列问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1463/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1463/</id>
    <published>2017-05-18T15:46:51.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>最长公共子序列问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:846 Accepted:280</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找出X和Y的最长公共子序列。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入序列X，第二行输入序列Y。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>X和Y的最长公共子序列的长度。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>abcbdab<br>bdcaba</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>4</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;class LCS {public:    LCS();    int LCSLength();private:    int **c, m, n;    char *x, *y;};LCS::LCS() {    string s;    cin &gt;&gt; s;    m = s.length();    x = new char [m+2];    x[0] = &#39;0&#39;; x[m+1] = &#39;\0&#39;;    for(int i=0; i&lt;m; i++) {        x[i+1] = s[i];    }    cin &gt;&gt; s;    n = s.length();    y = new char [n+2];    y[0] = &#39;0&#39;; y[n+1] = &#39;\0&#39;;    for(int i=0; i&lt;n; i++) {        y[i+1] = s[i];    }    c = new int * [m+1];    for(int i=0; i&lt;=m; i++) {        c[i] = new int [n+1];    }}int LCS::LCSLength() {    int i, j;    for(i=1; i&lt;=m; i++)        c[i][0]=0;    for(i=1; i&lt;=n; i++)        c[0][i]=0;    for(i=1; i&lt;=m; i++) {        for(j=1; j&lt;=n; j++) {            if(x[i] == y[j]) {                c[i][j]=c[i-1][j-1]+1;            }            else if(c[i-1][j] &gt;= c[i][j-1]) {                c[i][j]=c[i-1][j];            }            else {                c[i][j]=c[i][j-1];            }        }    }    return c[m][n];}int main() {    LCS lcs;    cout &lt;&lt; lcs.LCSLength();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最长公共子序列问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:846 Accepted:280&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; 
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1462 矩阵连乘问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1462/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1462/</id>
    <published>2017-05-18T15:35:14.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵连乘问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:455 Accepted:306</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>给定n个矩阵{A0,A1,…,An-1}， 其中Ai，i=0,…,n-1的维数为pi*pi+1，并且Ai与Ai+1是可乘的。考察这n个矩阵的连乘积A0A1…An-1，由于矩阵乘法满足结合律，所以计算矩阵的连乘可有许多不同的计算次序。矩阵连乘问题是确定计算矩阵连乘积的计算次序，使得按照这一次序计算矩阵连乘积，需要的“数乘”次数最少。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入n的值，第二行输入n个矩阵的维数pi（i=0，…，n）。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>最少乘法次数。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>6<br>30 35 15 5 10 20 25</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>15125</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;class MatrixChain {public:    MatrixChain() {        int i;        cin &gt;&gt; n;        p = new int [n+1];        for(i=0; i&lt;=n; i++) {            cin &gt;&gt; p[i];        }        m = new int * [n];        for(i=0; i&lt;n; i++)            m[i] = new int [n];        s = new int * [n];        for(i=0; i&lt;n; i++)            s[i] = new int [n];    }    int MChain();    //int LookupChain();    //void Traceback();private:    int *p, **m, **s, n;    //int LookupChain(int i, int j);    //void Traceback(int i, int j);};int MatrixChain::MChain() {    int i, j, r, k, t;    for(i=0; i&lt;n; i++) {        m[i][i]=0;    }    for(r=2; r&lt;=n; r++) {        for(i=0; i&lt;=n-r; i++) {            j=i+r-1;            m[i][j]=m[i+1][j]+p[i]*p[i+1]*p[j+1];            s[i][j]=i;            for(k=i+1; k&lt;j; k++) {                t=m[i][k]+m[k+1][j]+p[i]*p[k+1]*p[j+1];                if(t &lt; m[i][j]) {                    m[i][j]=t;                    s[i][j]=k;                }            }        }    }    return m[0][n-1];}int main() {    MatrixChain mc;    cout &lt;&lt; mc.MChain();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;矩阵连乘问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:455 Accepted:306&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; cla
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1461 多段图问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1461/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1461/</id>
    <published>2017-05-18T15:34:57.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>多段图问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:405 Accepted:269</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>多段图G=(V,E)是一个带权有向图，它具有如下特性：图中的结点被划分成k&gt;=2个互不相交的子集Vi，1&lt;=i&lt;=k。其中V1和Vk分别只有一个结点，V1包含源点（source）s，Vk包含汇点（sink）t。对所有边属于E，多段图要求若u属于Vi，则v属于Vi＋1，1&lt;=i&lt; k，每条边的权值为c(u,v)。从s到t的路径长度是这条路径上边的权值之和，多段图问题（multistage graph problem）是求从s到t的一条长度最短的路径。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入结点个数n和边的个数m，以下m行输入各有向边的两个结点u、v及该边上的代价。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>从s到t的最短的路径的长度。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>4 4<br>0 1 5<br>0 2 1<br>1 3 3<br>2 3 10</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>8</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;struct ENode {    int adjVex;    int weight;    ENode *nextArc;};class Graph {public:    Graph(int v, int e);    int FMultiGraph();    void test() {        int i;        cout &lt;&lt; endl;        for(i=0; i&lt;vSize; i++) {            cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;            ENode *p = a[i];            while(p) {                cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p-&gt;adjVex &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;)&quot;;                p = p-&gt;nextArc;            }            cout &lt;&lt; endl;        }    }protected:    ENode **a;    int vSize, eSize;};Graph::Graph(int v, int e) {    vSize=v; eSize=e;    int i, u;    ENode *p;    a = new ENode* [vSize];    for(i=0; i&lt;vSize; i++) a[i]=NULL;    for(i=0; i&lt;eSize; i++) {        p = new ENode;        cin &gt;&gt; u &gt;&gt; p-&gt;adjVex &gt;&gt; p-&gt;weight;        p-&gt;nextArc = a[u];        a[u] = p;    }}int Graph::FMultiGraph() {    int c, *cost=new int [vSize];    int q, *d=new int [vSize], *p=new int [vSize];    int j, v, min;    cost[vSize-1]=0; d[vSize-1]=-1;    for(j=vSize-2; j&gt;=0; j--) {        min = 32768;        for(ENode *r=a[j]; r; r=r-&gt;nextArc) {            v=r-&gt;adjVex;            if(r-&gt;weight + cost[v] &lt; min) {                min = r-&gt;weight + cost[v];                q = v;            }        }        cost[j]=min; d[j]=q;    }    c=cost[0];    delete [] cost; delete [] d; return c;}int main() {    int v, e;    cin &gt;&gt; v &gt;&gt; e;    Graph g(v, e);    //g.test();    cout &lt;&lt; g.FMultiGraph();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多段图问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:405 Accepted:269&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; clas
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1460 最小代价生成树</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1460/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1460/</id>
    <published>2017-05-18T15:34:52.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>Minimum-Cost Spanning Tree</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:512 Accepted:237</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>一个无向连通图的生成树是一个极小连通子图，它包括图中全部结点，并且有尽可能少的边。一棵生成树的代价是树中各条边上的代价之和。一个网络的各生成树中，具有最小代价的生成树称为该网络的最小代价生成树（minimum-cost spanning tree）。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入结点个数n和边的个数m，以下m行输入各边的两个结点u、v及该边上的代价。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>如果有生成树，则输出最小生成树的代价；如果没有生成树，则输出”no spanning tree”。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>6 10<br>1 2 10<br>1 4 30<br>1 5 45<br>2 3 50<br>2 5 40<br>2 6 25<br>3 5 35<br>3 6 15<br>4 6 20<br>5 6 55</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>105</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;#define INFTY 32768struct ENode {    int adjVex;    int weight;    ENode *nextArc;};class Graph {public:    Graph();    bool IsConnected();    void Prim(int s);    void test() {        int i;        cout &lt;&lt; endl;        for(i=0; i&lt;vSize; i++) {            cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot;;            ENode *p = a[i];            while(p) {                cout &lt;&lt; &quot;-&gt;&quot; &lt;&lt; p-&gt;adjVex &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;weight &lt;&lt; &quot;)&quot;;                p = p-&gt;nextArc;            }            cout &lt;&lt; endl;        }    }protected:    ENode **a;    int vSize, eSize;    void DFS_Travel(int u, bool *visited);    void Prim(int k, int *nearest, int *lowcost);};Graph::Graph() {    cin &gt;&gt; vSize &gt;&gt; eSize;    int i, u, v, w;    ENode *p, *q;    a = new ENode* [vSize];    for(i=0; i&lt;vSize; i++) a[i]=NULL;    for(i=0; i&lt;eSize; i++) {        p = new ENode;        q = new ENode;        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        u--; v--;        p-&gt;adjVex = u;        q-&gt;adjVex = v;        p-&gt;weight = q-&gt;weight = w;        p-&gt;nextArc = a[v];        a[v] = p;        q-&gt;nextArc = a[u];        a[u] = q;    }}bool Graph::IsConnected() {    bool *visited = new bool [vSize];    for(int i=0; i&lt;vSize; i++) {        visited[i]=false;    }    DFS_Travel(0, visited);    for(int i=0; i&lt;vSize; i++) {        if(visited[i] == false) {            cout &lt;&lt; &quot;no spanning tree&quot;;            return false;        }    }    return true;}void Graph::DFS_Travel(int u, bool *visited) {    ENode *w;    visited[u]=true;    for(w=a[u]; w; w=w-&gt;nextArc) {        int v=w-&gt;adjVex;        if(visited[v]==false)            DFS_Travel(v, visited);    }}void Graph::Prim(int s) {    int *nearest = new int [vSize];    int *lowcost = new int [vSize];    Prim(s, nearest, lowcost);    int cost=0;    for(int j=0; j&lt;vSize; j++) {        cost+=lowcost[j];    }    cout &lt;&lt; cost;    delete [] nearest;    delete [] lowcost;}void Graph::Prim(int k, int *nearest, int *lowcost) {    bool *mark = new bool [vSize];    ENode *p;    if(k&lt;0 || k&gt;vSize-1) return;    for(int i=0; i&lt;vSize; i++) {        nearest[i]=-1;        mark[i]=false;        lowcost[i]=INFTY;    }    lowcost[k]=0;    nearest[k]=k;    mark[k]=true;    for(int i=0; i&lt;vSize; i++) {        for(p=a[k]; p; p=p-&gt;nextArc) {            int j=p-&gt;adjVex;            if(! mark[j] &amp;&amp; lowcost[j]&gt;p-&gt;weight) {                lowcost[j]=p-&gt;weight;                nearest[j]=k;            }        }        int min=INFTY;        for(int j=0; j&lt;vSize; j++) {            if(!mark[j] &amp;&amp; lowcost[j]&lt;min) {                min=lowcost[j];                k=j;            }        }        mark[k]=true;    }}int main() {    Graph g;    //g.test();    if(g.IsConnected())        g.Prim(0);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Minimum-Cost Spanning Tree&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:512 Accepted:237&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1459 带时限的作业排序问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1459/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1459/</id>
    <published>2017-05-18T15:34:04.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>带时限的作业排序问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:729 Accepted:309</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>设有一个单机系统、无其它资源限制且每个作业运行相等时间，不妨假定每个作业运行1个单位时间。现有n个作业，每个作业都有一个截止期限di&gt;0，di为整数。如果作业能够在截止期限之内完成，可获得pi&gt;0的收益。问题要求得到一种作业调度方案，该方案给出作业的一个子集和该作业子集的一种排列，使得若按照这种排列次序调度作业运行，该子集中的每个作业都能如期完成，并且能够获得最大收益。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入n的值，以下n行输入作业号i，收益pi，截止期限di。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>n个作业的一个最优子集。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>4<br>1 100 2<br>2 10 1<br>3 15 2<br>4 27 1</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>1 4</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;typedef struct {    int no;    int p;    int d;}JOB;void Sort_by_p(JOB *job, int n) {    int i, j;    JOB tmp;    for(i=0; i&lt;n; i++) {        for(j=i+1; j&lt;n; j++) {            if(job[i].p &lt; job[j].p) {                tmp=job[i];                job[i]=job[j];                job[j]=tmp;            }        }    }}int JS(JOB *job, int *x, int n) {    int k=0, j, r, i;    x[0]=0;    cout &lt;&lt; job[x[k]].no &lt;&lt; &quot; &quot;;    for(j=1; j&lt;n; j++) {        r=k;        while(r&gt;=0 &amp;&amp; job[x[r]].d&gt;job[j].d &amp;&amp; job[x[r]].d&gt;r+1)            r--;        if((r&lt;0 || job[x[r]].d&lt;=job[j].d) &amp;&amp; job[j].d&gt;r+1) {            for(i=k; i&gt;=r+1; i--)                x[i+1]=x[i];            x[r+1]=j;            cout &lt;&lt; job[j].no &lt;&lt; &quot; &quot;;            k++;        }    }    return k;}int main() {    JOB *job;    int n, i;    cin &gt;&gt; n;    job = new JOB [n];    for(i=0; i&lt;n; i++) {        cin &gt;&gt; job[i].no &gt;&gt; job[i].p &gt;&gt; job[i].d;    }    Sort_by_p(job, n);    int *x = new int [n];    JS(job, x, n);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;带时限的作业排序问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:729 Accepted:309&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot;
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1458 部分背包问题</title>
    <link href="http://blog.tomate.cn/2017/05/18/ahnu-oj1458/"/>
    <id>http://blog.tomate.cn/2017/05/18/ahnu-oj1458/</id>
    <published>2017-05-18T15:32:33.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<p>部分背包问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:839 Accepted:329</p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>已知一个载重为M的背包和n件物品，第i件物品的重量为 wi，如果将第i件物品全部装入背包，将有收益pi，这里，wi&gt;0，pi&gt;0。所谓背包问题是指求一种最佳装载方案，使得收益最大。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行物品个数n和背包载重M，以下n行输入物品编号i，物品收益pi，物品重量wi。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>x1,x2,…,xn，0&lt;=xi&lt;=1，每个xi是第i件物品装入背包中的部分（小数位保留二位）。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><p>3 20<br>1 25 18<br>2 24 15<br>3 15 10</p><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><p>0.00 1.00 0.50</p><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;void SumOfSub(int s, int k, int r, int **x, int m, int *w, int n, int &amp;count) {    x[k][1]=1;    if(s+w[k] == m) {        count++;        int i, j;        for(i=0; i&lt;n; i++) {            for(j=0; j&lt;=k; j++) {                if(x[j][0] == i) {                    cout &lt;&lt; x[j][1] &lt;&lt; &quot; &quot;;                    break;                }            }            if(j &gt; k)                cout &lt;&lt; &quot;0 &quot;;        }        cout &lt;&lt; endl;    }    else if(s+w[k]+w[k+1] &lt;= m)        SumOfSub(s+w[k], k+1, r-w[k], x, m, w, n, count);    if(s+r-w[k]&gt;=m &amp;&amp; s+w[k+1]&lt;=m) {        x[k][1]=0;        SumOfSub(s, k+1, r-w[k], x, m, w, n, count);    }}void SumOfSub(int **x, int n, int m, int *w, int &amp;count) {    int r=0;    for(int i=0; i&lt;n; i++)        r+=w[i];    if(r&gt;=m &amp;&amp; w[0]&lt;=m)        SumOfSub(0, 0, r, x, m, w, n, count);}int main() {    int n, M, count=0;    cin &gt;&gt; n &gt;&gt; M;    int *w = new int [n];    int **x = new int * [n];    for(int i=0; i&lt;n; i++)        x[i] = new int [2];    for(int i=0; i&lt;n; i++) {         cin &gt;&gt; w[i];        x[i][0]=i;    }    int i, j, t;    for(i=0; i&lt;n; i++) {        for(j=i+1; j&lt;n; j++) {            if(w[i] &gt; w[j]) {                t=w[i]; w[i]=w[j]; w[j]=t;                t=x[i][0]; x[i][0]=x[j][0]; x[j][0]=t;            }        }    }    SumOfSub(x, n, M, w, count);    if(count==0)        cout &lt;&lt; &quot;no solution!&quot;;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;部分背包问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:839 Accepted:329&lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; cla
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>SoftEther VPN 服务搭建（Linux 版）</title>
    <link href="http://blog.tomate.cn/2017/05/14/setup-softether-vpn-server-on-linux-vps/"/>
    <id>http://blog.tomate.cn/2017/05/14/setup-softether-vpn-server-on-linux-vps/</id>
    <published>2017-05-14T04:59:29.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具材料"><a href="#工具材料" class="headerlink" title="工具材料"></a>工具材料</h2><ul><li>VPS / 云服务器（本文以 <code>Ubuntu Server 14.04.1 LTS 64bit</code> 系统为例）</li><li>SoftEther VPN Server（<a href="http://www.softether-download.com/cn.aspx" target="_blank" rel="noopener">官方下载</a>（被墙））</li><li>SoftEther VPN Client（<a href="http://www.softether-download.com/cn.aspx" target="_blank" rel="noopener">官方下载</a>（被墙）<a href="https://pan.baidu.com/s/1mhY6NkG" target="_blank" rel="noopener">网盘下载</a>）</li><li>putty（<a href="http://www.putty.org/" target="_blank" rel="noopener">下载地址</a>）</li></ul><h2 id="安装-SoftEther-VPN-Server"><a href="#安装-SoftEther-VPN-Server" class="headerlink" title="安装 SoftEther VPN Server"></a>安装 SoftEther VPN Server</h2><p>1.登录到 VPS</p><p>Linux / OS X 下直接在 <code>terminal</code> 中登录：</p><pre><code class="bash">ssh username@vps_ip</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4368698-65a8971f26d71ab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Windows 下使用 <code>putty</code> 登录</p><p>2.更新一下 <code>apt-get</code> 源并安装gcc等工具</p><pre><code class="bash">sudo apt-get updatesudo apt-get install build-essential</code></pre><p>3.下载 <code>SoftEther VPN Server</code> （也可以使用 <code>scp</code> 从本地上传到云服务器）</p><pre><code class="bash"># 32bit 执行这个wget http://opxbtqu6c.bkt.clouddn.com/SoftEther-VPN/softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz# 64bit 执行这个wget http://opxbtqu6c.bkt.clouddn.com/SoftEther-VPN/softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4368698-9a4ee5c7234a21ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>4.使用 <code>tar</code> 解压，会产生一个 <code>vpnserver</code> 文件夹</p><pre><code class="bash">tar xvf softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4368698-568de4bad530e2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>5.进入 <code>vpnserver</code> 文件夹，然后安装</p><pre><code class="bash">cd vpnservermake</code></pre><p>连续输3次1同意许可协议<br><img src="http://upload-images.jianshu.io/upload_images/4368698-e9602a8974b7691f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/4368698-5e3cebbfa949a5cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="配置-SoftEther-VPN-Server"><a href="#配置-SoftEther-VPN-Server" class="headerlink" title="配置 SoftEther VPN Server"></a>配置 SoftEther VPN Server</h2><p>1.开启 <code>vpn</code> 服务</p><pre><code class="bash">sudo /home/ubuntu/vpnserver/vpnserver start</code></pre><p>2.执行以下命令，然后依次输入1、回车、回车</p><pre><code class="bash">/home/ubuntu/vpnserver/vpncmd</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/4368698-97b006b192194254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/4368698-a4130440cda70a40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>3.输入以下命令设置管理密码，之后按 <code>Ctrl+C</code> 退出 vpncmd</p><pre><code>ServerPasswordSet</code></pre><p>4.将 <code>vpnserver</code> 加入开机启动项（可选）</p><pre><code class="bash">vi /etc/rc.local</code></pre><p>按 <code>i</code> 键，将 <code>/home/ubuntu/vpnserver/vpnserver start</code> 写入文件，按下 <code>ESC</code> ，输入 <code>:wq</code> 退出</p><h2 id="管理-SoftEther-VPN-Server"><a href="#管理-SoftEther-VPN-Server" class="headerlink" title="管理 SoftEther VPN Server"></a>管理 SoftEther VPN Server</h2><p>SoftEther 提供了 <code>图形界面</code> 的 <code>vpn server</code> 管理工具，目前有 <code>Windows</code> 版和 <code>OS X</code> 版（推荐 win 版，支持中文）</p><p>1.打开 VPN Server Manager ，添加新设置</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-f49bf1352f334d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt=""></p><p>填入server端的 <code>ip</code> 和 <code>端口</code> 以及 <code>管理员</code> 的 <code>密码</code></p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-de74be5b6b6b8c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>2.连接server端</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-4dd18fe21c8d191a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt=""></p><p>勾选远程访问</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-c0446980957046a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>默认 VPN</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-0012b56d655b0df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-d25b5b955befc212.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>如果需要开启其他平台的设备连接 VPN ，则勾选并设置秘钥</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-fb01b749218ac0d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>禁用 VPN Azure</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-3001db760593919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-328d0f8bcc393bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>创建用户，填入用户名、密码，验证类型选密码验证</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-e01480e134e56167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><h2 id="连接-SoftEther-VPN-Server"><a href="#连接-SoftEther-VPN-Server" class="headerlink" title="连接 SoftEther VPN Server"></a>连接 SoftEther VPN Server</h2><p>SoftEther 也提供了 <code>图形界面</code> 的 <code>SoftEther VPN Client</code></p><p>1.安装 <code>SoftEther VPN Client</code> ，然后打开</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-3e9fcf6fcde3a065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>2.添加新的连接</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-020e09218b76b19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>使用默认的 <code>VPN</code> 作为适配器名</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-57917ea02d75b49b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-e14faab13ca513d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>3.再次点击添加新的连接</p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-020e09218b76b19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>填入server端的 <code>ip</code> 和 <code>端口</code> 以及server端添加的 <code>用户</code>的 <code>用户名</code> 和 <code>密码</code></p><p><img src="http://upload-images.jianshu.io/upload_images/4368698-46e42a2abb1fa370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt=""></p><p>4.回到主界面连接即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工具材料&quot;&gt;&lt;a href=&quot;#工具材料&quot; class=&quot;headerlink&quot; title=&quot;工具材料&quot;&gt;&lt;/a&gt;工具材料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;VPS / 云服务器（本文以 &lt;code&gt;Ubuntu Server 14.04.1 LTS 64bit&lt;/co
      
    
    </summary>
    
      <category term="VPN" scheme="http://blog.tomate.cn/categories/VPN/"/>
    
    
      <category term="VPN" scheme="http://blog.tomate.cn/tags/VPN/"/>
    
      <category term="SoftEther" scheme="http://blog.tomate.cn/tags/SoftEther/"/>
    
      <category term="Linux" scheme="http://blog.tomate.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>单个循环实现冒泡排序</title>
    <link href="http://blog.tomate.cn/2017/05/07/bubble-sort-one-loop/"/>
    <id>http://blog.tomate.cn/2017/05/07/bubble-sort-one-loop/</id>
    <published>2017-05-07T08:22:11.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<ul><li>普通的冒泡排序</li></ul><pre><code class="c">void BubbleSort(int arr[], int n) {    int i, j, t;    for(i=0; i&lt;n; i++) {        for(j=i+1; j&lt;n; j++) {            if(arr[i]&gt;arr[j]) {                t=arr[i]; arr[i]=arr[j]; arr[j]=t;            }        }    }}</code></pre><ul><li>使用一层循环实现的冒泡排序</li></ul><pre><code class="c">// 用宏实现变量交换#define Swap(a,b,c) ((c)=(a),(a)=(b),(b)=(c))// 第一种void BubbleSortOneLoop(int arr[], int n){    int i = 0;    int l = 0;    while (i &lt; n - 1) //i还是控制最外层    {        if (arr[l] &gt; arr[l +1])        {            int temp = 0;            Swap(arr[l], arr[l + 1], temp);        }        l++;        if (l &gt;=n - i-1) //只不过在特殊点的时候改变l和i        {            l = 0;            i++;        }    }}// 第二种void BubbleSortOneLoop(int arr[], int n){    int i = 0;    int l = 0;    int temp;    while (i&lt;n*n-1) //大次数为n*n-1，%n实现下标循环    {        if (arr[l%n] &gt; arr[l%n + 1] &amp;&amp; l%n&lt;n-1-(i/n)) //直接判断        {            temp = 0;            Swap(arr[l%n], arr[l%n + 1], temp);        }        l++; i++;    }}</code></pre><p>冒泡法时间复杂度为 <code>O(n^2)</code> ，这个是改不了的，不可能因为用一个循环实现，就变成了 <code>O(n)</code>。所以，并没有什么卵用，只是一种写代码的方式而已。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;普通的冒泡排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void BubbleSort(int arr[], int n) {
    int i, j, t;
    for(i=0; i&amp;lt;n; i++) {
        fo
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.tomate.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="冒泡排序" scheme="http://blog.tomate.cn/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题：从 url 到页面展现，这中间发生了什么？</title>
    <link href="http://blog.tomate.cn/2017/05/07/interview-url-to-page-what-happened/"/>
    <id>http://blog.tomate.cn/2017/05/07/interview-url-to-page-what-happened/</id>
    <published>2017-05-07T07:38:04.000Z</published>
    <updated>2018-03-17T05:38:43.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们平常在地址栏里输入一些网址时，页面很快就会出现，但在这之中到底发生了什么事情呢？</p></blockquote><h1 id="大概是这样的流程："><a href="#大概是这样的流程：" class="headerlink" title="大概是这样的流程："></a>大概是这样的流程：</h1><ul><li>在浏览器的地址栏中敲入了url</li><li>DNS 解析</li><li>服务器处理请求</li><li>浏览器处理</li><li>绘制网页</li></ul><h2 id="一、在浏览器的地址栏中敲入了url"><a href="#一、在浏览器的地址栏中敲入了url" class="headerlink" title="一、在浏览器的地址栏中敲入了url"></a>一、在浏览器的地址栏中敲入了url</h2><h3 id="url是什么"><a href="#url是什么" class="headerlink" title="url是什么"></a>url是什么</h3><p>URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上的资源，实际上就是网站网址。url的格式一般为：</p><p>协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名<br>其中协议类型可以是http（超文本传输协议）、https、ftp（文件传输协议）、telnet（远程登录协议）、file等等。而http是最常见的网络传输协议，https则是进行加密的网络传输。</p><p>例如，网址 <code>http://rocj.site/2017/post</code> ，其中，“http”表示与web服务器通讯采用 <code>http协议</code> ，web服务器域名为rocj.site，2017/post表示所访问的文件存在于web服务器上的路径。</p><p>url格式中主机名冒号后面的数字是端口编号，因为一台计算机常常会同时作为Web，FTP等服务器，端口编号用来告诉web服务器所在的主机要将请求交给哪个服务。默认情况下http服务的端口为80，不需要在url中输入，如果web服务器采用的不是这一个默认端口，就需要写明服务所用的端口。常见的协议默认端口如下：</p><table><thead><tr><th style="text-align:center">协议类型</th><th style="text-align:center">默认端口</th></tr></thead><tbody><tr><td style="text-align:center">http</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">ftp</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">https</td><td style="text-align:center">443</td></tr><tr><td style="text-align:center">telnet</td><td style="text-align:center">23</td></tr></tbody></table><h3 id="IP是什么"><a href="#IP是什么" class="headerlink" title="IP是什么"></a>IP是什么</h3><p>IP是因特网中的每台连接到网络的计算机为实现相互通信而遵循的规则协议。每个处于互联网中的设备都有IP 地址，形如 192.168.0.1，而127.0.0.1代表本机的 IP。IP又分为局域网IP和公网IP。而局域网 IP 和公网 IP 是有差别的。每个网站就是靠IP来定位的。</p><p>为了便于记忆或辨识，人们使用域名来登录网站，每个域名背后有对应的IP地址。</p><p>比如对于 <code>http://www.jianshu.com</code> 的URL，浏览器实际上不知道 <code>www.jianshu.com</code> 到底是什么东西，需要查找 <code>www.jianshu.com</code> 网站所在服务器的IP地址，才能找到目标，这就是下文要说的域名解析。</p><h2 id="二、DNS-解析"><a href="#二、DNS-解析" class="headerlink" title="二、DNS 解析"></a>二、DNS 解析</h2><p>当用户在浏览器中输入url后</p><h3 id="查找浏览器缓存"><a href="#查找浏览器缓存" class="headerlink" title="查找浏览器缓存"></a>查找浏览器缓存</h3><p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入 <code>chrome://net-internals/#dns</code> ，就可以看到了<br><img src="http://upload-images.jianshu.io/upload_images/5308475-1edd5a71a8c33fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="查找操作系统缓存"><a href="#查找操作系统缓存" class="headerlink" title="查找操作系统缓存"></a>查找操作系统缓存</h3><p>如果用户的浏览器缓存中没有，浏览器会从hosts文件查找是否有存储DNS信息，查找是否有目标域名和对应的IP地址</p><h3 id="查找路由器缓存"><a href="#查找路由器缓存" class="headerlink" title="查找路由器缓存"></a>查找路由器缓存</h3><p>如果系统缓存中也找不到，那么查询请求就会发向路由器，路由器一般会有自己的DNS缓存。</p><h3 id="查找-ISP-DNS-缓存"><a href="#查找-ISP-DNS-缓存" class="headerlink" title="查找 ISP DNS 缓存"></a>查找 ISP DNS 缓存</h3><p>如果路由器缓存中也找不到，那么就查询 ISP DNS 缓存服务器了。<br>我们都知道在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，比如 <code>114.114.114.114</code> ,也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。而 <code>114.114.114.114</code> 是国内移动、电信和联通通用的DNS。</p><h3 id="递归查找"><a href="#递归查找" class="headerlink" title="递归查找"></a>递归查找</h3><p>如果前面都找不到DNS缓存的话，会有以下几个步骤：</p><ul><li>本地 DNS服务器将该请求转发到互联网上的根域（根域没有名字，在DNS系统中就用一个空字符串来表示。例如 <code>www.baidu.com</code> .现在的DNS系统都不会要求域名以.来结束，即 <code>www.baidu.com</code> 就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）</li><li>根域将所要查询域名中的顶级域（比如要查询 <code>www.baidu,com</code> ，该域名的顶级域就是 <code>com</code> ）的服务器IP地址返回到本地DNS。</li><li>本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求， com域服务器再将域名中的二级域（即 <code>www.baidu.com</code> 中的 <code>baidu.com</code> ）的IP地址返回给本地DNS。</li><li>本地DNS再向二级域发送请求进行查询。</li><li>之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</li></ul><p>下图能很好的说明这个递归查找:<br><img src="http://upload-images.jianshu.io/upload_images/5308475-cf58e66c93c1f2ec.gif?imageMogr2/auto-orient/strip" alt=""></p><p>当查找到对应的IP地址之后，通过IP地址查找到对应的服务器，浏览器将用户发起的http请求发送给服务器。例如：<code>GET http://www.baidu.com/ HTTP/1.1</code></p><h2 id="三、服务器处理请求"><a href="#三、服务器处理请求" class="headerlink" title="三、服务器处理请求"></a>三、服务器处理请求</h2><p>每台服务器上都会安装处理请求的应用——<code>Web server</code>。常见的web server产品有<code>apache</code>、<code>nginx</code>、<code>IIS</code>、<code>Lighttpd</code>等。</p><p>当web server接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理对应请求的程序进行处理（例如CGI脚本，JSP脚本，servlets，ASP脚本，服务器端JavaScript，或者一些其它的服务器端技术等）。</p><p>无论它们(脚本)的目的如何，这些服务器端(server-side)的程序通常产生一个HTML的响应(response)来让浏览器可以浏览。</p><p>那么如何处理请求？实际上就是后台处理的工作。后台开发现在有很多框架，但大部分都还是按照<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC设计模式</a>进行搭建的。</p><p>处理的过程如下图：<br><img src="http://upload-images.jianshu.io/upload_images/5308475-d45e8967170041f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>MVC的处理过程是这样的：对于每一个用户输入的请求，首先被控制器接收，控制器决定用哪个模型来进行处理，然后模型用业务逻辑来处理用户的请求并返回数据，最后控制器确定用哪个视图模型，用相应的视图格式化模型返回html字符串给浏览器，并通过显示页面呈现给用户。</p><h2 id="四、浏览器处理"><a href="#四、浏览器处理" class="headerlink" title="四、浏览器处理"></a>四、浏览器处理</h2><p>接下来就是浏览器进行处理， 通过后台处理返回的HTML字符串被浏览器接受后被一句句读取解析，html页面经历加载、解析、渲染。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>浏览器对一个html页面的加载顺序是从上而下的。如果加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树，也就是DOM树。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5308475-3817847173a249ef.gif?imageMogr2/auto-orient/strip" alt=""></p><p>css解析是指将css文件解析为样式表对象。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5308475-810853491150d1ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>js解析是文件在加载的同时也进行解析<br>如果想深入如何解析的话可以看浏览器的工作原理：新式网络浏览器幕后揭秘这篇文章</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>即为构建渲染树的过程，就是将DOM树进行可视化表示。构建这棵树是为了以正确的顺序绘制文档内容。</p><h2 id="五、绘制网页"><a href="#五、绘制网页" class="headerlink" title="五、绘制网页"></a>五、绘制网页</h2><p>浏览器根据 HTML 和 CSS 计算得到渲染树，最终绘制到屏幕上</p><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">出处</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们平常在地址栏里输入一些网址时，页面很快就会出现，但在这之中到底发生了什么事情呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;大概是这样的流程：&quot;&gt;&lt;a href=&quot;#大概是这样的流程：&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="面试题" scheme="http://blog.tomate.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="前端" scheme="http://blog.tomate.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://blog.tomate.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="http" scheme="http://blog.tomate.cn/tags/http/"/>
    
      <category term="域名" scheme="http://blog.tomate.cn/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="DNS" scheme="http://blog.tomate.cn/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>克隆 Github 项目的非 master 分支</title>
    <link href="http://blog.tomate.cn/2017/05/01/clone-non-master-branch-on-github/"/>
    <id>http://blog.tomate.cn/2017/05/01/clone-non-master-branch-on-github/</id>
    <published>2017-05-01T08:37:33.000Z</published>
    <updated>2018-03-17T05:38:43.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Step-1-Clone-Repo"><a href="#Step-1-Clone-Repo" class="headerlink" title="Step.1 Clone Repo"></a>Step.1 Clone Repo</h3><p>切换路径</p><pre><code class="bash">$ cd path</code></pre><p>克隆仓库</p><pre><code class="bash">$ git clone git@github.com:username/Repo.git</code></pre><h3 id="Step-2-Checkout-Branch"><a href="#Step-2-Checkout-Branch" class="headerlink" title="Step.2 Checkout Branch"></a>Step.2 Checkout Branch</h3><p>进入目录</p><pre><code class="bash">$ cd RepoPath</code></pre><p>创建并跟踪分支</p><pre><code class="bash">$ git checkout -b branchName origin/branchName</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Step-1-Clone-Repo&quot;&gt;&lt;a href=&quot;#Step-1-Clone-Repo&quot; class=&quot;headerlink&quot; title=&quot;Step.1 Clone Repo&quot;&gt;&lt;/a&gt;Step.1 Clone Repo&lt;/h3&gt;&lt;p&gt;切换路径&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Git" scheme="http://blog.tomate.cn/categories/Git/"/>
    
    
      <category term="clone" scheme="http://blog.tomate.cn/tags/clone/"/>
    
      <category term="branch" scheme="http://blog.tomate.cn/tags/branch/"/>
    
      <category term="github" scheme="http://blog.tomate.cn/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>OJ1457 第K小元素问题</title>
    <link href="http://blog.tomate.cn/2017/03/21/ahnu-oj1457/"/>
    <id>http://blog.tomate.cn/2017/03/21/ahnu-oj1457/</id>
    <published>2017-03-21T13:29:52.000Z</published>
    <updated>2018-03-17T05:38:43.948Z</updated>
    
    <content type="html"><![CDATA[<p>第K小元素问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:664 Accepted:293 </p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>用分治法编程解决在n个数当中找第K小元素问题（注意：不能用排序）。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入n的值，第二行输入n个数，第三行输入K的值。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>n个数中的第K小元素。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><pre><code>58 1 3 6 93</code></pre><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><pre><code>6</code></pre><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;class SortableList {public:    void Input();    int Partition(int p, int q);    int K_Min(int p, int q, int k);    void solve();protected:    int l[1000];    int length;    int k;};void SortableList::Input() {    int i;    cin &gt;&gt; length;    for(i=0; i&lt;length; i++) {        cin &gt;&gt; l[i];    }    cin &gt;&gt; k;}int SortableList::Partition(int p, int q) {    int x=l[p];    int i=p, tmp;    for(int j=p+1; j&lt;=q; j++) {        if(l[j] &lt;= x) {            i++;            tmp=l[i];            l[i]=l[j];            l[j]=tmp;        }    }    tmp=l[p];    l[p]=l[i];    l[i]=tmp;    return i;}int SortableList::K_Min(int p, int q, int k) {    if(p == q)        return l[p];    int j=Partition(p, q);    while(k!=j+1) {        if(k &lt; j+1)            q=j-1;        else            p=j+1;        j=Partition(p, q);    }    return l[j];}void SortableList::solve() {    cout &lt;&lt; K_Min(0, length-1, k);}int main() {    SortableList list;    list.Input();    list.solve();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第K小元素问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:664 Accepted:293 &lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; c
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
  <entry>
    <title>OJ1456 最大最小元问题</title>
    <link href="http://blog.tomate.cn/2017/03/21/ahnu-oj1456/"/>
    <id>http://blog.tomate.cn/2017/03/21/ahnu-oj1456/</id>
    <published>2017-03-21T13:17:27.000Z</published>
    <updated>2018-03-17T05:38:43.948Z</updated>
    
    <content type="html"><![CDATA[<p>最大最小元问题</p><p>Time Limit:1000MS  Memory Limit:65536K<br>Total Submit:798 Accepted:296 </p><h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>请改写教材中的分治算法MaxMin，使其可以输出n个数中的最大值和次最大值以及最小值和次最小值（注意：不能用排序）。</p><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第一行输入数的个数n，第二行输入n个数。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>第一行输出最大值和次最大值，第二行输出最小值和次最小值。</p><h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5><pre><code>32 1 3</code></pre><h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5><pre><code>3 21 2</code></pre><h5 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h5><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;class SortableList {public:    void Input();    int Partition(int p, int q);    int K_Min(int p, int q, int k);    void solve();protected:    int l[1000];    int length;};void SortableList::Input() {    int i;    cin &gt;&gt; length;    for(i=0; i&lt;length; i++) {        cin &gt;&gt; l[i];    }}int SortableList::Partition(int p, int q) {    int x=l[p];    int i=p, tmp;    for(int j=p+1; j&lt;=q; j++) {        if(l[j] &lt;= x) {            i++;            tmp=l[i];            l[i]=l[j];            l[j]=tmp;        }    }    tmp=l[p];    l[p]=l[i];    l[i]=tmp;    return i;}int SortableList::K_Min(int p, int q, int k) {    if(p == q)        return l[p];    int j=Partition(p, q);    while(k!=j+1) {        if(k &lt; j+1)            q=j-1;        else            p=j+1;        j=Partition(p, q);    }    return l[j];}void SortableList::solve() {    cout &lt;&lt; K_Min(0, length-1, length) &lt;&lt; &#39; &#39; &lt;&lt; K_Min(0, length-1, length-1) &lt;&lt; endl;    cout &lt;&lt; K_Min(0, length-1, 1) &lt;&lt; &#39; &#39; &lt;&lt; K_Min(0, length-1, 2);}int main() {    SortableList list;    list.Input();    list.solve();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最大最小元问题&lt;/p&gt;
&lt;p&gt;Time Limit:1000MS  Memory Limit:65536K&lt;br&gt;Total Submit:798 Accepted:296 &lt;/p&gt;
&lt;h5 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; c
      
    
    </summary>
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/categories/AHNU-OJ/"/>
    
    
      <category term="AHNU OJ" scheme="http://blog.tomate.cn/tags/AHNU-OJ/"/>
    
      <category term="OJ" scheme="http://blog.tomate.cn/tags/OJ/"/>
    
  </entry>
  
</feed>
