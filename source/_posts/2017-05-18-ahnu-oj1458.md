---
title: "OJ1458 部分背包问题"
tags:
  - AHNU OJ
  - OJ
categories: AHNU OJ
toc: false
comment: true
notag: false
date: 2017-05-18 23:32:33
thumbnail: http://upload-images.jianshu.io/upload_images/4368698-798467a9d8e45280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
---

部分背包问题

Time Limit:1000MS  Memory Limit:65536K
Total Submit:839 Accepted:329

##### Description

已知一个载重为M的背包和n件物品，第i件物品的重量为 wi，如果将第i件物品全部装入背包，将有收益pi，这里，wi>0，pi>0。所谓背包问题是指求一种最佳装载方案，使得收益最大。

##### Input

第一行物品个数n和背包载重M，以下n行输入物品编号i，物品收益pi，物品重量wi。

##### Output

x1,x2,…,xn，0<=xi<=1，每个xi是第i件物品装入背包中的部分（小数位保留二位）。

##### Sample Input

3 20
1 25 18
2 24 15
3 15 10

##### Sample Output

0.00 1.00 0.50

##### Source

```cpp
#include <iostream>
using namespace std;

void SumOfSub(int s, int k, int r, int **x, int m, int *w, int n, int &count) {
	x[k][1]=1;
	if(s+w[k] == m) {
		count++;
		int i, j;
		for(i=0; i<n; i++) {
			for(j=0; j<=k; j++) {
				if(x[j][0] == i) {
					cout << x[j][1] << " ";
					break;
				}
			}
			if(j > k)
				cout << "0 ";
		}
		cout << endl;
	}
	else if(s+w[k]+w[k+1] <= m)
		SumOfSub(s+w[k], k+1, r-w[k], x, m, w, n, count);
	if(s+r-w[k]>=m && s+w[k+1]<=m) {
		x[k][1]=0;
		SumOfSub(s, k+1, r-w[k], x, m, w, n, count);
	}
}

void SumOfSub(int **x, int n, int m, int *w, int &count) {
	int r=0;
	for(int i=0; i<n; i++)
		r+=w[i];
	if(r>=m && w[0]<=m)
		SumOfSub(0, 0, r, x, m, w, n, count);
}

int main() {
	int n, M, count=0;
	cin >> n >> M;
	int *w = new int [n];
	int **x = new int * [n];
	for(int i=0; i<n; i++)
		x[i] = new int [2];
	for(int i=0; i<n; i++) { 
		cin >> w[i];
		x[i][0]=i;
	}
	int i, j, t;
	for(i=0; i<n; i++) {
		for(j=i+1; j<n; j++) {
			if(w[i] > w[j]) {
				t=w[i]; w[i]=w[j]; w[j]=t;
				t=x[i][0]; x[i][0]=x[j][0]; x[j][0]=t;
			}
		}
	}
	SumOfSub(x, n, M, w, count);
	if(count==0)
		cout << "no solution!";
	return 0;
}
```